@using FastDragBlazor.Components
@using System.Diagnostics
@using FastDragBlazor

@* Magic list building *@

@if (_root is not null)
{
    <div class="channel-tab-wrapper">
        <ContextMenuTrigger MouseButtonTrigger="MouseButtonTrigger.ContextOrHold" MenuId='list-context'>
            <DragWrapper @ref="@_dragWrapper" TItem="NestedChannel" TabSize="20" Class="channel-wrapper" UsePaddingTabs="true" OnChangeAsync="OnSortingChange">
                @foreach (var item in _ordered)
                {
                    <DragItem @key="@item.Channel.Id" @ref="@item.Component" TItem="NestedChannel" Class="item" StartDepth="@item.Depth" Height="30" IsContainer="@item.IsCategory">
                        <div class="channel" @onmousedown="async () => await OnContextMenu(item.Channel)" @onclick="item.OnClicked" @onclick:stopPropagation="true">
                            <img alt="@item.AltText" src="@item.IconUrl" style="@item.GetIconStyle()"/>
                            <p>@item.Channel.Name</p>
                        </div>
                    </DragItem>
                }
            </DragWrapper>
        </ContextMenuTrigger>
        <div class="channel-fade-left"></div>
        <div class="channel-fade-right"></div>
    </div>
}

@code {

    [Parameter]
    public Planet Planet { get; set; }

    /* The root channel object */
    private List<NestedChannel> _root = new();
    private List<NestedChannel> _ordered = new();

    /* Lists for channels and building */
    private List<PlanetChannel> _allChannels = new();
    private List<PlanetCategory> _topCategories = new();
    
    /* Wrapper component */
    private DragWrapper<NestedChannel> _dragWrapper;

    private bool _canRender = true;
    protected override bool ShouldRender() => _canRender;

    /* Js interop */

    protected override async Task OnInitializedAsync()
    {
        ModelObserver<PlanetChatChannel>.OnAnyUpdated += 
            async (e) => await OnChannelUpdated(e.NewToClient, e.Model);
        ModelObserver<PlanetCategory>.OnAnyUpdated += 
            async (e) => await OnChannelUpdated(e.NewToClient, e.Model);
        ModelObserver<PlanetVoiceChannel>.OnAnyUpdated += 
            async (e) => await OnChannelUpdated(e.NewToClient, e.Model);
        
        ModelObserver<PlanetChatChannel>.OnAnyDeleted += 
            async (e) => await OnChannelDeleted(e);
        ModelObserver<PlanetCategory>.OnAnyDeleted += 
            async (e) => await OnChannelDeleted(e);
        ModelObserver<PlanetVoiceChannel>.OnAnyDeleted += 
            async (e) => await OnChannelDeleted(e);
        
        Planet = WindowManager.Instance.FocusedPlanet;
        await BuildList();
    }

    public async Task OnChannelUpdated(bool created, PlanetChannel channel)
    {
        if (channel.PlanetId != Planet.Id)
            return;
        
        if (created)
        {
            await BuildList();
            ReRender();
        }
    }

    private async Task OnChannelDeleted(PlanetChannel channel)
    {
        if (channel.PlanetId != Planet.Id)
            return;
        
        Console.WriteLine("CHANNEL DELETED");
        
        var nested = _ordered.FirstOrDefault(x => x.Channel.Id == channel.Id);
        _dragWrapper.RemoveItem(nested);
        ReRender();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        Console.WriteLine("Rendered");
        _canRender = false;
    }

    // Generates the entire list structure
    public async Task BuildList()
    {
        var categories = await Planet.GetCategoriesAsync();
        var chatChannels = await Planet.GetChannelsAsync();
        var voiceChannels = await Planet.GetVoiceChannelsAsync();
        
        _allChannels.Clear();
        _allChannels.AddRange(categories);
        _allChannels.AddRange(chatChannels);
        _allChannels.AddRange(voiceChannels);

        _topCategories.Clear();
        foreach (var cat in categories)
        {
            if (cat.ParentId is null)
                _topCategories.Add(cat);
        }

        Console.WriteLine("TOP CATS: " + _topCategories.Count);

        Stopwatch sw = new();
        sw.Start();

        var defaultRole = await Planet.GetDefaultRoleAsync();
        
        // Build entire list
        _root = _topCategories.OrderByDescending(x => x.Position).Select(x => new NestedChannel(this, Planet, defaultRole, x)).ToList();

        foreach (var child in _root)
        {
            await child.LoadChildren(_allChannels);
        }
        
        sw.Stop();
        Console.WriteLine("Channel list structure built in " + sw.ElapsedMilliseconds);

        _ordered.Clear();

        foreach (var child in _root)
        {
            AddToOrdered(child);
        }

        _canRender = true;
        StateHasChanged();
    }

    private void AddToOrdered(NestedChannel nested)
    {
        _ordered.Add(nested);
        foreach (var child in nested.Children)
        {
            AddToOrdered(child);
        }
    }
        
    private async Task OnSortingChange(DragEventData<NestedChannel> eventData)
    {
        var movedChannel = eventData.MovedItem.Channel;

        var newParentId = eventData.TargetContainer?.Channel?.Id;
        bool parentChanged = newParentId  != movedChannel.ParentId;
        
        movedChannel.ParentId = newParentId;

        List<long> idOrder;

        if (movedChannel.ParentId is not null)
        {
            idOrder = new();
            
            // Get new container elements
            var parentItem = _dragWrapper.Items.FirstOrDefault(x => x.Data == eventData.TargetContainer);
            var parentIndex = _dragWrapper.Items.IndexOf(parentItem);
            
            for (int i = parentIndex + 1; i < _dragWrapper.Items.Count; i++)
            {
                var item = _dragWrapper.Items[i];
                if (item.Depth >= parentItem.Depth)
                    break; // We have hit the end of the children
                
                else if (item.Depth == parentItem.Depth - 1)
                    idOrder.Add(item.Data.Channel.Id); // Direct child
                
                else
                    continue; // Skip over children of children
            }
        }
        else
        {
            // Just get order of top level channels
            idOrder = _dragWrapper.Items.Where(x => x.Depth == 0).Select(x => x.Data.Channel.Id).ToList();
        }


    }

    private string GetIconSource(PlanetChannel channel)
    {
        return "";
    }

    public void ToggleExpand(DragItem<NestedChannel> item)
    {
        _dragWrapper.ToggleExpanded(item.Data);
    }

    private async Task OnContextMenu(PlanetChannel channel)
    {
        await ChannelListContextMenuComponent.SetSelectedItem(channel);
    }

    public void RecalcPositions()
    {
        if (_dragWrapper is not null)
            _dragWrapper.RecalculatePositions();
    }

    public void ReRender()
    {
        RecalcPositions();
        _canRender = true;
        StateHasChanged();
    }
}