@*

@using Valour.Sdk.Extensions
@inherits WindowBase
@inject IJSRuntime JsRuntime

<div class="window-wrapper"
     style="z-index: @GetZIndex(); left:  @(_left)px; top:  @(_top)px; width: @(_width)px; height: @(_height)px;"
     @ref="@_element">
    <div class="tab-wrapper"
         @onmousedown:stopPropagation="true"
         @onmousedown="@OnClickTab">
        <div class="tab">
            <div class="tab-info">
                <img alt="tab icon" class="tab-icon" src="@WindowTab.Icon"/>
                <span class="tab-title">@WindowTab.Title</span>
            </div>
            <div class="tab-buttons"
                 @onclick:stopPropagation="true"
                 @onmousedown:stopPropagation="true">
                @if (WindowTab.Type != typeof(HomeWindowComponent))
                {
                    <span class="home" @onclick="@OnClickHome">
                        <i class="bi bi-house-door-fill"></i>
                    </span>
                }
                <span class="minus" @onclick="@OnClickMinus">
                    <i class="bi bi-dash-circle-fill"></i>
                </span>
            </div>
        </div>
    </div>
    <div class="window"
         style="@(WindowTab.AutoScroll ? "overflow-y: auto" : "")"
         @onmousedown:stopPropagation="true"
         @onmousedown="@OnClickWindow">
        <DynamicComponent Type="@WindowTab.Type" Parameters="@_windowParams"/>
    </div>
</div>

@code {
    [Parameter]
    public DockFloaters Container { get; set; }
    
    [Parameter]
    public WindowTab WindowTab { get; set; }
    
    public override async Task ReplaceAsync(WindowTab newTab)
    {
        await WindowTab.NotifyClose();
        
        newTab.CopyAllNonDefaultTo(WindowTab);
        _windowParams = new Dictionary<string, object>()
        {
            {"Window", WindowTab},
            {"Data", WindowTab.Data}
        };

        ReRender();
    }
    
    public override async Task CloseAsync()
    {
        await WindowTab.NotifyClose();
        await Container.RemoveFloater(WindowTab);
    }
    
    private IJSInProcessObjectReference _jsModule;
    private ElementReference _element;
    private DotNetObjectReference<FloatingWindow> _dotnetRef;
    
    private double _left;
    private double _top;

    private double _width;
    private double _height;

    private Dictionary<string, object> _windowParams;

    private bool _render = false;

    protected override void OnInitialized()
    {
        _windowParams = new Dictionary<string, object>()
        {
            {"Window", WindowTab},
            {"Data", WindowTab.Data}
        };

        _left = WindowTab.StartFloatX;
        _top = WindowTab.StartFloatY;
        
        _width = WindowTab.StartFloatWidth;
        _height = WindowTab.StartFloatHeight;
    }

    protected override bool ShouldRender() => _render;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine("Floater first render " + WindowTab.Id);
            _dotnetRef = DotNetObjectReference.Create(this);
            _jsModule = await JsRuntime.InvokeAsync<IJSInProcessObjectReference>("import", "./_content/Valour.Client/Components/DockWindows/FloatingWindow.razor.js");
            await _jsModule.InvokeVoidAsync("enableDrag", _element, _dotnetRef, WindowTab.StartFloatX, WindowTab.StartFloatY);
        }
        
        _render = false;
        
        Console.WriteLine("Rendered " + WindowTab.Id);
    }
    
    public override void NotifyNeedsReRender()
    {
        // Floating windows do NOT re-render via blazor
        // ReRender();
        
        // Instead, we use JS to re-render the window
        _jsModule.InvokeVoid("reRender", _element, Container.ActiveFloater.Id == WindowTab.Id);
    }

    public class FloaterPositionData
    {
        public double ClientX { get; set; }
        public double ClientY { get; set; }
    }
    
    public async Task<FloaterPositionData> GetPositionAsync()
    {
        var pos =  await _jsModule.InvokeAsync<double[]>("getPosition", _element);
        return new FloaterPositionData()
        {
            ClientX = pos[0],
            ClientY = pos[1]
        };
    }
    
    public override async Task AddSiblingWindow(WindowTab newTabTab)
    {
        // Get current window position
        var pos = await GetPositionAsync();
        
        await Container.AddFloater(newTabTab, pos.ClientX + 50, pos.ClientY + 50);
    }
    
    private async Task OnClickMinus()
    {
        await CloseAsync();
    }

    private int GetZIndex()
    {
        if (Container?.ActiveFloater == WindowTab)
            return 101;

        return 100;
    }
    
    private async Task OnClickTab()
    {
        Container.SetActiveFloater(this.WindowTab);
        await WindowService.SetGlobalActiveWindowAsync(this.WindowTab);
    }

    private async Task OnClickWindow()
    {
        Container.SetActiveFloater(this.WindowTab);
        await WindowService.SetGlobalActiveWindowAsync(this.WindowTab);
    }
    
    private async Task OnClickHome()
    {
        var newData = new WindowTab()
        {
            Title = "Home",
            Icon = "./_content/Valour.Client/media/logo/logo-128.png",
            Type = typeof(HomeWindowComponent)
        };

        var pos = await GetPositionAsync();
        _top = pos.ClientY;
        _left = pos.ClientX;

        await ReplaceAsync(newData);
    }

    [JSInvokable]
    public async Task OnDragStart()
    {
        await Container.NotifyDragging(this.WindowTab);
    }
    
    [JSInvokable]
    public async Task OnDragEnd()
    {
        await Container.NotifyStopDragging();
    }

    public void ReRender()
    {
        _render = true;
        StateHasChanged();
    }
}