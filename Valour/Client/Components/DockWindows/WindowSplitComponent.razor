<div @onmousedown="@HandleMouseDown" style="@Styles" class="window-split @Classes">
</div>

@code {
    [Parameter]
    public WindowSplit Split { get; set; }

    public string Classes
    {
        get
        {
            return Split.SplitDirection == SplitDirection.Horizontal ? "horizontal" : "vertical";
        }
    }

    public string Styles
    {
        get
        {
            var styles = string.Empty;
            
            // Should match layout in direction of split
            if (Split.SplitDirection == SplitDirection.Horizontal)
            {
                styles += $"height: {Split.Layout.Position.Height}%; width: {WindowLayout.SliderSize}px;";
            }
            else
            {
                styles += $"height: {WindowLayout.SliderSize}px; width: {Split.Layout.Position.Width}%;";
            }
            
            // Position shift is based off child one size
            if (Split.SplitDirection == SplitDirection.Horizontal)
            {
                styles += $"top: {Split.Layout.Position.OffsetY}%; left: calc({Split.Layout.Position.OffsetX + Split.Layout.ChildOne.Position.Width}% - {WindowLayout.SliderSize / 2}px);";
            }
            else
            {
                styles += $"top: calc({Split.Layout.Position.OffsetY + Split.Layout.ChildOne.Position.Height}% - {WindowLayout.SliderSize / 2}px); left: {Split.Layout.Position.OffsetX}%;";
            }
            
            return styles;
        }
    }

    protected override void OnInitialized()
    {
        Split.Component = this;
    }

    private float _dragStartX;
    private float _dragStartY;

    public Task HandleMouseDown(MouseEventArgs e)
    {
        _dragStartX = (float)e.ClientX;
        _dragStartY = (float)e.ClientY;
        
        MouseListener.SubscribeMouseMove(HandleMouseMove);
        MouseListener.SubscribeMouseUp(HandleMouseUp);
        
        return Task.CompletedTask;
    }
    
    public Task HandleMouseMove(MouseMoveEvent e)
    {
        // Convert delta to split ratio change
        
        // First get size of parent
        var firstChild = Split.Layout.ChildOne.Tabs.FirstOrDefault();
        if (firstChild is null)
        {
            Console.WriteLine("No first child when determining layout size!");
            return Task.CompletedTask;
        }
        
        var secondChild = Split.Layout.ChildTwo.Tabs.FirstOrDefault();
        if (secondChild is null)
        {
            Console.WriteLine("No second child when determining layout size!");
            return Task.CompletedTask;
        }

        var firstSize = BrowserUtils.GetElementDimensions(firstChild.Component.OuterWindowRef);
        var secondSize = BrowserUtils.GetElementDimensions(secondChild.Component.OuterWindowRef);
        
        var firstPxSize = Split.SplitDirection == SplitDirection.Horizontal ? firstSize.Width : firstSize.Height;
        var secondPxSize = Split.SplitDirection == SplitDirection.Horizontal ? secondSize.Width : secondSize.Height;
        
        // we can get total size using the split ratio
        // split ratio refers to first child size
        var totalSizePx = firstPxSize + secondPxSize;
        
        // Console.WriteLine("Total size: " + totalSizePx);
        
        // turn delta into change in split ratio
        
        var ratioChange = (Split.SplitDirection == SplitDirection.Horizontal ? e.DeltaX : e.DeltaY) / totalSizePx;
        
        // update split ratio
        Split.SplitRatio += ratioChange;
        
        // Split ratio should be between 0.1 and 0.9
        if (Split.SplitRatio < 0.1f)
        {
            Split.SplitRatio = 0.1f;
        }
        else if (Split.SplitRatio > 0.9f)
        {
            Split.SplitRatio = 0.9f;
        }
        
        // update layout
        Split.Layout.RecalculatePosition();
        
        // re-render
        Split.Layout.ReRenderRecursive();
        
        // re-render split
        StateHasChanged();
        
        return Task.CompletedTask;
    }
    
    public Task HandleMouseUp(MouseUpEvent e)
    {
        MouseListener.UnsubscribeMouseMove(HandleMouseMove);
        return Task.CompletedTask;
    }
}