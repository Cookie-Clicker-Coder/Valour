@using Valour.Api.Items.Messages
@inject IJSRuntime JS
@implements IDisposable

@if (MessageData == null || MessageData.IsEmpty)
{
    return;
}

@{
    var width = "";
    if (Reply)
        width = "fit-content";
}

<div style="width: @width" class="message-outer">
    <ContextMenuTrigger @onpointerdown:stopPropagation="true" MenuId="message-context">
        <div @onpointerdown='OnPointerDown' @oncontextmenu='OnPointerDown'>
            <div id="@Id" class="@Class message-base" @ref='this_ref' tabindex='0'>

                @if (Minimal)
                {
                    <div class="time-container">
                        <p class="time">
                            @MessageData.Message.TimeSent.ToLocalTime().ToShortTimeString().Replace(' ', '\0')
                        </p>
                    </div>
                    <div class="message-content">

                        <p class="content" @ref="InnerRef">

                            @if (MessageData.Message.Attachments != null && MessageData.Message.Attachments.Count > 0)
                            {
                                var i = 0;

                                @foreach (var attachment in MessageData.Message.Attachments)
                                {
                                    var par = new Dictionary<string, object>()
                                    {
                                        { "Attachment", attachment }
                                    };

                                    var id = i;

                                    <div class="attachment-wrapper" @onclick="async () => await OnClickAttachment(id)">
                                        @if (Ghost)
                                        {
                                            <div class="attachment-x">x</div>
                                        }
                                        <DynamicComponent Type="attachment.GetComponentType()" Parameters="par"></DynamicComponent>
                                    </div>

                                    i++;
                                }
                            }

                            @if (MessageData.Message.Embed != null && MessageData.Message.Embed.Pages.Count > 0)
                            {
                                <EmbedComponent embed="@MessageData.Message.Embed" Message="MessageData"></EmbedComponent>
                            }
                            else
                            {
                                string key = "";

                                if (Ghost)
                                {
                                    key = $"ghost-{Window.Id}";
                                }
                                else
                                {
                                    key = $"content-{MessageData.Message.MessageIndex}-{MessageData.Message.TimeSent}-{Window.Id}";
                                }

                                <MessageContentComponent @key="key" @ref="ContentComponent" Message="MessageData"></MessageContentComponent>
                            }
                        </p>
                    </div>

                }
                else
                {
                    <div style="display:inline-block; position: absolute">
                        <img class="author-pfp" src="@pfpurl" @onerror="OnPfpError" />
                        <div class="time-container">
                            <p class="time">
                                @MessageData.Message.TimeSent.ToLocalTime().ToShortTimeString().Replace(' ', '\0')
                            </p>
                        </div>
                    </div>
                    <div class="message-content">

                        <div style="width: max-content">
                            <ContextMenuTrigger MenuId="@ContextMenuId" @onpointerdown='InitializeContextMenu' style='display:inline'>
                                <p class="author-name" style="color: @nameColor;">
                                    @name
                                </p>
                            </ContextMenuTrigger>

                            <p class="role-name">
                                &nbsp;- @nameTag
                            </p>
                        </div>


                        @if (ReplyMessage is not null && !Reply)
                        {
                            string replykey = $"reply-{Window.Id}";

                            Dictionary<string, object> replyParams = new()
                            {
                                { "MessageData", ReplyMessage },
                                { "Key", replykey },
                                { "Submessage", true },
                                { "LastMessage", null },
                                { "Reply", true },
                                { "Ghost", Ghost }
                            };
                            
                            <DynamicComponent Type="ReplyMessage.GetComponentType()" Parameters="replyParams"></DynamicComponent>

                            <MessageComponent MessageData="ReplyMessage" Key="@replykey"  Submessage="true" Ghost="Ghost" Last_Message="null" Reply="true"></MessageComponent>
                        }
                        <p class="content" @ref="InnerRef">

                            @if (MessageData.Message.Attachments != null && 
                                 MessageData.Message.Attachments.Count > 0)
                            {
                                var i = 0;

                                @foreach (var attachment in MessageData.Message.Attachments)
                                {
                                    var par = new Dictionary<string, object>()
                                    {
                                        { "Attachment", attachment }
                                    };

                                    var id = i;

                                    <div class="attachment-wrapper" @onclick="async () => await OnClickAttachment(id)">
                                        @if (Ghost)
                                        {
                                            <div class="attachment-x">x</div>
                                        }
                                        <DynamicComponent Type="attachment.GetComponentType()" Parameters="par"></DynamicComponent>
                                    </div>

                                    i++;
                                }
                            }

                            @if (MessageData.Message.Embed != null && MessageData.Message.Embed.Pages.Count > 0)
                            {

                                Console.WriteLine(MessageData.Message.Embed.Pages.Count);

                                <EmbedComponent embed="@MessageData.Message.Embed" Message="MessageData"></EmbedComponent>
                            }
                            else
                            {
                                string key = "";

                                if (Ghost)
                                {
                                    key = $"ghost-{Window.Id}";
                                }
                                else
                                {
                                    key = $"content-{MessageData.Message.MessageIndex}-{MessageData.Message.TimeSent}-{Window.Id}";
                                }

                                <MessageContentComponent @key="key" @ref="ContentComponent" Message="MessageData"></MessageContentComponent>
                            }
                        </p>
                    </div>

                    @if (Reply)
                    {
                        <div class="reply-x">x</div>
                    }
                }
            </div>
        </div>
    </ContextMenuTrigger>
</div>

@code {
    [CascadingParameter]
    public MessageHolderComponent Holder { get; set; }

    [CascadingParameter]
    public ChatChannelWindow Window { get; set; }

    [Parameter]
    public ClientMessageWrapper MessageData { get; set; }

    [Parameter]
    public ClientMessageWrapper LastMessage { get; set; }

    [Parameter]
    public string Key { get; set; }

    [Parameter]
    public bool Ghost { get; set; }

    [Parameter]
    public bool Reply { get; set; }

    [Parameter]
    public bool Submessage { get; set; }

    public User User { get; set; }

    public virtual string ContextMenuId => "general-message-context";

    public MessageContentComponent ContentComponent;

    public ElementReference InnerRef;

    public bool ShouldRenderValue = false;

    public bool Minimal = false;

    public ClientMessageWrapper ReplyMessage;

    public ElementReference this_ref;

    public string Id = "";

    public string nameColor = "#ffffff";

    public string nameTag = "Default";

    public string pfpurl = "_content/Valour.Client/icon-512.png";

    public string name = "";

    public bool Edit = false;

    bool mentioned = false;

    public string Class
    {
        get
        {
            string _class = "";

            if (Minimal)
            {
                _class += "multi-message";
            }
            else
            {
                _class += "message";
            }

            if (mentioned)
            {
                _class += " mentioned";
            }

            if (Edit)
            {
                _class += " edit";
            }

            if (Reply)
            {
                _class += " reply";
            }

            if (Ghost)
            {
                _class += " ghost";
            }

            if (ReplyMessage is not null)
            {
                _class += " hasreply";
            }

            return _class;
        }
    }

    // This is handled here because we don't want to go from
    // Valour.Client -> Valour.Api
    public virtual async Task InitializeContextMenu()
    {

    }

    public async Task OnPointerDown()
    {
        if (Ghost)
        {
            if (Reply)
            {
                Console.WriteLine("Removing replyto");
                var input = Window.Component.InputComponent;
                await input.RemoveReply();

            }
        }
        else
        {
            await WindowManager.Instance.SetSelectedWindow(Window);

            // Initialize message
            await MessageContextMenuComponent.Initialize(MessageData, Window.Component, this);
        }
    }

    public async Task OnClickAttachment(int id)
    {
        if (Ghost)
        {
            var input = Window.Component.InputComponent;
            await input.RemoveAttachment(id);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("OnMessageLoad", InnerRef);
    }

    public async Task OpenEditMode()
    {
        // Remove this when it's ready for prod
        return;

        //await this_ref.FocusAsync();

        Edit = true;
        ReRender();

        await Window.Component.OpenEditMode(this);
    }

    public async Task CloseEditMode()
    {
        if (!Edit)
            return;

        Edit = false;
        ReRender();
    }

    public async Task SetMessage(ClientMessageWrapper message)
    {
        this.MessageData = message;
        await BuildMessage();

        ReRender();
    }

    public async Task RefreshMessage()
    {
        await BuildMessage();
        StateHasChanged();
    }

    public void SetLast(ClientMessageWrapper msg)
    {
        LastMessage = msg;
    }

    public async Task BuildMessage()
    {
        if (MessageData == null)
            return;

        // Get reference to reply message if we have a reply
        if (MessageData.Message.ReplyToId is not null)
            ReplyMessage = new ClientMessageWrapper(await MessageData.Message.GetReplyMessageAsync());

        // Check if we are a minimal message
        CheckMinimal();

        if (!Submessage)
            mentioned = await MessageData.Message.CheckIfMentioned();

        if (Minimal)
        {
            return;
        }

        name = await MessageData.Message.GetAuthorNameAsync();
        nameColor = await MessageData.Message.GetAuthorColorAsync();
        nameTag = await MessageData.Message.GetAuthorTagAsync();
        pfpurl = await MessageData.Message.GetAuthorImageUrlAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        if (MessageData is null)
            return;

        Id = $"m-{MessageData.Message.ChannelId}-{MessageData.Message.MessageIndex}";

        if (!Submessage)
        {
            Holder.AddRenderedMessage(this);
        }

        User = await MessageData.Message.GetAuthorUserAsync();

        await BuildMessage();

        if (User != null)
            User.OnUpdated += OnUserUpdated;
    }

    public async Task OnUserUpdated(int flags)
    {
        name = await MessageData.Message.GetAuthorNameAsync();
        pfpurl = await MessageData.Message.GetAuthorImageUrlAsync();

        ReRender();
    }

    public void CheckMinimal()
    {
        if (LastMessage != null && MessageData != null)
        {
            if (ReplyMessage is not null)
            {
                Minimal = false;
                return;
            }
            if (LastMessage.Message.AuthorUserId == MessageData.Message.AuthorUserId)
            {
                Minimal = true;
                return;
            }
        }

        Minimal = false;
    }

    public void ReRender()
    {
        if (Ghost && Reply) return;

        ShouldRenderValue = true;
        StateHasChanged();

        ContentComponent?.ReRender();

        ShouldRenderValue = false;
    }

    void IDisposable.Dispose()
    {
        if (Holder != null)
        {
            Holder.RemoveRenderedMessage(this);
        }
    }

    protected async Task OnPfpError()
    {
        pfpurl = "_content/Valour.Client/icon-512.png";

        Console.WriteLine("pfp error caught");

        ReRender();
    }

    /// <summary>
    /// This prevents the message from re-rendering. This should be expanded to support message edits in the future.
    /// </summary>
    protected override bool ShouldRender()
    {
        if (Ghost && Reply) return false;

        return ShouldRenderValue;
    }

}
