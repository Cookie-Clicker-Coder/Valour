@inherits ChannelListItemComponent
@implements IDisposable

@inject WindowManager WindowManager
@inject ChannelListManager ListManager

<div
    class="channel-wrapper"
    draggable="true"
    
    @onclick:stopPropagation="true"
    @onclick="OnClick"

    @ondragstart:stopPropagation="true"
    @ondragstart="@OnDragStart"

    @ondrop:stopPropagation="true"
    @ondrop="@OnDropOn"

    @onpointerdown:stopPropagation="true"
    @onpointerdown='@PrepareContext'

    @ondragleave:stopPropagation="true"
    @ondragleave="@OnDragLeave">
    
    @if (ListManager.DragOverId == Channel.Id &&
         ListManager.DragIsTop)
    {
        <div
            class="drop-line"
            @ondragenter:stopPropagation="true"
            ondragenter="return false;">
        </div>
    }
    <div
        class="@ChosenCss"
        id="@Channel.Id">

        @{ var iconData = GetIconData(); }

        @if (_notificationCount > 0)
        {
            <div class="channel-icon-holder">
                <img class="channel-icon" src="@iconData[0]" alt="@iconData[1]"/>
                <p>@_notificationCount</p>
            </div>
        }
        else
        {
            <img class="channel-icon" src="@iconData[0]" alt="@iconData[1]"/>
        }


        <p class="name">
            @Channel.Name
        </p>

    </div>
    @if (ListManager.DragOverId == Channel.Id &&
         !ListManager.DragIsTop)
    {
        <div
            class="drop-line"
            @ondragenter:stopPropagation="true"
            ondragenter="return false;">
        </div>
    }
    <div
        class="drop top"
        @ondragenter:stopPropagation="true"
        @ondragenter="@OnDragEnterTop">
    </div>
    <div
        class="drop bottom"
        @ondragenter:stopPropagation="true"
        @ondragenter="@OnDragEnterBottom">
    </div>
</div>

@code {
    

   

    

    

    private async Task OnClick()
    {

        ListManager.OnItemClickInCategory(Channel, ParentCategory);

        var window = WindowManager.GetSelectedWindow();
        
        if (window is ChatChannelWindow channelWindow)
        {
            // It's the same channel, cancel
            if (channelWindow.Channel.Id == Channel.Id)
                return;

            await channelWindow.Component.SwapChannel(Channel);
        }
        else
        {
            var planet = await Channel.GetPlanetAsync();
            await WindowManager.ReplaceWindow(window, new PlanetChatChannelWindow(planet, Channel));
        }
        
        Refresh();
    }

    public async Task OnChatChannelUpdate(ModelUpdateEvent<PlanetChatChannel> eventData)
    {
        var channel = eventData.Model;
        if (Channel.Id == channel.Id)
        {
            await DetermineLock();
            Refresh();
        }
    }

    public async Task OnChannelOpenedChange(PlanetChatChannel channel)
    {
        //if (channel.Id == Channel.Id)
        Refresh();
    }

    public async Task DetermineLock()
    {
        HasLock = false;
        Planet planet = await Channel.GetPlanetAsync();

        var role = await planet.GetDefaultRoleAsync();

        var node = await Channel.GetPermNodeAsync(role.Id, ChannelType.PlanetChatChannel);
        if (node is not null) {
            var state = node.GetPermissionState(ChatChannelPermissions.View);
            if (state == PermissionState.False)
                HasLock = true;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Console.WriteLine("Init " + Channel.Name);

        ModelObserver<PlanetChatChannel>.OnAnyUpdated += OnChatChannelUpdate;

        ValourClient.OnChannelOpen += OnChannelOpenedChange;
        ValourClient.OnChannelClose += OnChannelOpenedChange;

        ValourClient.OnUserChannelStateUpdate += OnUserChannelStateUpdate;
        ValourClient.OnChannelStateUpdate += OnChannelStateUpdate;

        ValourClient.OnNotificationReceived += OnNotification;

        DetermineNotifications();
        DetermineUnread();
        await DetermineLock();
    }

    public async Task OnNotification(Notification notification)
    {
        if (notification.ChannelId != Channel.Id)
            return;
        
        DetermineNotifications();
        Refresh();
    }

    public async Task OnUserChannelStateUpdate(UserChannelState state)
    {
        if (state.ChannelId != Channel.Id)
            return;

        DetermineUnread();
        Refresh();
    }

    public async Task OnChannelStateUpdate(ChannelStateUpdate state)
    {
        if (state.ChannelId != Channel.Id)
            return;

        DetermineUnread();
        Refresh();
    }

    public void Dispose()
    {
        // Console.WriteLine("Disposed " + Channel.Name);

        ModelObserver<PlanetChatChannel>.OnAnyUpdated -= OnChatChannelUpdate;

        ValourClient.OnChannelOpen -= OnChannelOpenedChange;
        ValourClient.OnChannelClose -= OnChannelOpenedChange;
        ValourClient.OnUserChannelStateUpdate -= OnUserChannelStateUpdate;
        ValourClient.OnChannelStateUpdate -= OnChannelStateUpdate;
    }

    public void DetermineUnread()
    {
        IsUnread = ValourClient.GetChannelUnreadState(Channel.Id);
    }

    public void DetermineNotifications()
    {
        _notificationCount = ValourClient.GetChannelNotifications(Channel.Id);
    }
}