@inject HttpClient Http
@inject NavigationManager navManager
@inject IJSRuntime JS
@inject WindowManager windowManager
@implements IDisposable
@using Valour.Api.Items.Messages

<!-- Cascade a bunch of values that messages and subcomponents need -->
<CascadingValue Value='Channel'>
    <CascadingValue Value='Window'>
        <CascadingValue Value='this'>
            <CascadingValue Value='SelfMember'>
                    <div class="d-flex flex-column window" style="height:99%; max-width:100%;" id="window" @onclick="@OnClickWindow">

                        <div class="channel-info">
                            <h3 class="title">
                                @Channel.Name
                            </h3>
                            @if (!string.IsNullOrWhiteSpace(Channel.Description))
                            {
                                <p class="description">
                                    @Channel.Description
                                </p>
                            }

                            <div class="channel-buttons">
                                <div class="channel-home" @onclick="ReturnHome">
                                    Home
                                </div>
                                @if (windowManager.GetWindowCount() > 1)
                                {
                                    <div class="channel-close" @onclick="CloseWindow">
                                        X
                                    </div>
                                }
                            </div>

                        </div>

                        <CascadingValue Value='Channel_Permissions'>
                            <MessageHolderComponent @ref="MessageHolder" @key='$"mh-{Window.Id}"'></MessageHolderComponent>
                        </CascadingValue>

                        @{
                            var lastMessage = MessageHolder?.GetLastMessage();
                        }

                        <InputComponent @ref='InputComponent' />

                    </div>
            </CascadingValue>
        </CascadingValue>
    </CascadingValue>
</CascadingValue>

@code {

    /// <summary>
    /// True if the client has negotiated a channel connection
    /// </summary>
    private bool channelConnected;

    [Parameter]
    public ChatChannelWindow Window { get; set; }

    [CascadingParameter]
    public IModalService Modal { get; set; }

    public PlanetChatChannel Channel;

    public Planet Planet;

    public PlanetMember SelfMember;

    public Func<Task> ForceRefreshMessages;

    public bool ForceMessageRefresh;

    public MessageHolderComponent MessageHolder { get; set; }

    public InputComponent InputComponent { get; set; }

    public PermissionsNode Channel_Permissions { get; set; }

    public MessageComponent Edit_Message { get; set; }

    public bool Should_Render { get; set; }

    // Runs when page is initialized
    protected override async Task OnInitializedAsync()
    {
        Window.Component = this;

        Console.WriteLine("Initializing channel window component.");

        Channel = Window.Channel;

        Planet = await Window.Channel.GetPlanetAsync();

        ItemObserver<PlanetMember>.OnAnyUpdated += OnPlanetMemberUpdate;
        ItemObserver<PlanetRole>.OnAnyUpdated += OnRoleUpdate;
        ItemObserver<PlanetChatChannel>.OnAnyUpdated += OnChatChannelUpdate;

        ValourClient.OnMessageRecieved += OnRecieveMessage;
        ValourClient.OnMessageDeleted += OnDeleteMessage;

        await ValourClient.OpenChannel(Channel);

        await JS.InvokeVoidAsync("SetupWindow", Window.Id);

        await JS.InvokeVoidAsync("OnChannelLoad", null);

        await JS.InvokeVoidAsync("SetupWindow", Window.Id);

        await SetupNewChannelAsync();
    }

    public async Task OpenEditMode(MessageComponent message)
    {

    }

    protected override bool ShouldRender()
    {
        return Should_Render;
    }

    void IDisposable.Dispose()
    {
        ItemObserver<PlanetMember>.OnAnyUpdated -= OnPlanetMemberUpdate;
        ItemObserver<PlanetRole>.OnAnyUpdated -= OnRoleUpdate;
        ItemObserver<PlanetChatChannel>.OnAnyUpdated -= OnChatChannelUpdate;

        ValourClient.OnMessageRecieved -= OnRecieveMessage;
        ValourClient.OnMessageDeleted -= OnDeleteMessage;
    }

    public async Task OnChatChannelUpdate(PlanetChatChannel channel, bool newItem, int flags)
    {
        if (Channel.Id == channel.Id)
        {
            this.Channel = channel;
            Should_Render = true;
            StateHasChanged();
        }
    }

    public async Task OnPlanetMemberUpdate(PlanetMember member, bool newItem, int flags)
    {
        if (member.PlanetId != Planet.Id)
        {
            return;
        }

        foreach (var msg in MessageHolder.RenderedMessages.Where(x => x.Author.UserId == member.UserId))
        {
            //Console.WriteLine(msg.Message.Message_Index);

            // Update member reference
            msg.Author = member;
            await msg.RefreshMessage();
        }
    }

    public async Task OnRoleUpdate(PlanetRole role, bool newItem, int flags)
    {
        if (role.PlanetId != Planet.Id)
        {
            return;
        }

        foreach (var msg in MessageHolder.RenderedMessages.Where(x => x.roleId == role.Id))
        {
            await msg.RefreshMessage();
        }
    }

    public async Task CloseWindow()
    {
        await windowManager.CloseWindow(Window);
    }

    public async Task ReturnHome()
    {
        HomeWindow newWindow = new HomeWindow();
        await windowManager.ReplaceWindow(Window, newWindow);
    }

    public async Task SetupNewChannelAsync()
    {
        SelfMember = await PlanetMember.FindAsyncByUser(ValourClient.Self.Id, Channel.PlanetId);

        InputComponent.SelfMember = SelfMember;

        InputComponent.MessageHolder = MessageHolder;

        Channel_Permissions = await Channel.GetMemberPermissionsAsync(SelfMember.Id, Channel.PlanetId);

        MessageHolder.Clear();

        var msgs = ClientPlanetMessage.FromList(await Channel.GetLastMessagesAsync(64));

        foreach (var msg in msgs)
            await ValourCache.Put(msg.BaseMessage.Id, msg.BaseMessage);

        MessageHolder.AddMessages(msgs);
    }

    public async Task SwapChannel(PlanetChatChannel newchannel)
    {
        Channel = newchannel;

        await windowManager.SwapWindowChannel(Window, newchannel);

        await SetupNewChannelAsync();

        Should_Render = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        await JS.InvokeVoidAsync("ScrollWindowBottom", Window.Id);

        Should_Render = false;
    }

    public async Task OnWindowClosed()
    {
        Console.WriteLine($"Gracefully exiting channel {Channel.Id} due to window change.");
        await ValourClient.CloseChannelConnection(Channel);
    }

    public async Task OnRecieveMessage(PlanetMessage message)
    {
        // Ignore messages not meant for this channel
        if (message.ChannelId != Channel.Id)
            return;

        // Create client wrapper
        ClientPlanetMessage c_message = new ClientPlanetMessage(message);

        await MessageHolder.AddMessage(c_message);
        InputComponent.PreviewMessageComponent.SetLast(MessageHolder.GetLastMessage());
        InputComponent.PreviewMessageComponent.CheckMinimal();
        InputComponent.PreviewMessageComponent.ReRender();
    }

    public async Task OnDeleteMessage(PlanetMessage message)
    {
        if (message.ChannelId != Channel.Id)
            return;

        MessageHolder.Messages.RemoveAll(x => x.Id == message.Id);
        MessageHolder.QueuedMessages.RemoveAll(x => x.Id == message.Id);
        MessageHolder.ForceRefresh();
    }

    public async Task ScrollToBottom()
    {
        await JS.InvokeVoidAsync("ScrollWindowBottom", Window.Id);
    }

    public async Task ScrollToBottomAnim()
    {
        await JS.InvokeVoidAsync("ScrollWindowBottomAnim", Window.Id);
    }

    public async Task OnClickWindow()
    {
        await windowManager.SetFocusedPlanet(await Channel.GetPlanetAsync());
    }

    public async Task UpdateScrollPosition()
    {
        await JS.InvokeVoidAsync("UpdateScrollPosition", Window.Id);
    }

    public async Task ScaleScrollPosition()
    {
        await JS.InvokeVoidAsync("ScaleScrollPosition", Window.Id);
    }

    [JSInvokable("OnScrollTopInvoke")]
    public static async Task OnScrollTop(string id)
    {
        ChatChannelWindow Window = WindowManager.Instance.GetWindow(id) as ChatChannelWindow;
        MessageHolderComponent Holder = Window.Component.MessageHolder;

        if (Window == null)
        {
            Console.WriteLine("Channel window is null in OnScrollTop!");
            return;
        }

        if (Holder.Messages == null || Holder.Messages.Count == 0)
        {
            return;
        }

        long firstIndex = Holder.Messages[0].Message_Index;

        Console.WriteLine($"Fetching older messages from index {firstIndex} for window {Window.Id}");

        var messages = await Window.Channel.GetMessagesAsync(firstIndex, 32);

        if (messages == null || messages.Count() == 0)
        {
            return;
        }

        foreach (var msg in messages)
            await ValourCache.Put(msg.Id, msg, true);

        await Window.Component.UpdateScrollPosition(); // This saves the scroll position

        Holder.InsertMessages(0, ClientPlanetMessage.FromList(messages));

        //Window.Component.StateHasChanged();
        await Window.Component.ScaleScrollPosition(); // This ensures the page doesnt move harshly
    }
}
