@inject IJSRuntime JsRuntime
@inject WindowManager windowManager
@implements IAsyncDisposable
@using System.Net.Http.Headers
@using Valour.Api.Models.Messages;
@using Valour.TenorTwo.Models
@using Media = Valour.TenorTwo.Models.Media

<div class='@(CanUserPost ? string.Empty : "no-perms")'>
    <div class="preview-message">
        <MessageComponent @key="@(Window.Id + "-preview-message")" @ref="PreviewMessageComponent" MessageData="PreviewMessage" Ghost="true" LastMessage="WindowComponent.MessageHolder.GetLastMessage()" ></MessageComponent>
    </div>

    <ChannelCurrentlyTypingComponent ParentComponent="WindowComponent" Channel="WindowComponent.Channel"></ChannelCurrentlyTypingComponent>

    <div class="textbox-holder" @onclick="@MessageHolder.ScrollToBottomAnimated">
        <div style="position: relative">
            <TenorMenuComponent @key="@("tenor-menu-" + Window.Id)" @ref="TenorMenu" ChannelWindow="Window"></TenorMenuComponent>
        </div>
        <MentionSelectComponent @ref="MentionSelector" InputComponent="this"></MentionSelectComponent>

        <div class="textbox" @ref="DropZoneElement">
            <InputFile id="@("upload-core-" + Window.Id)" @ref="InputFile_Ref" style="width: 0; height: 0; display: none;" OnChange="LoadFiles"></InputFile>
            <button class="upload-btn" @onmousedown="@ShowUploadMenu" @onblur="@HideUploadMenu">
                <img class="upload" src="_content/Valour.Client/media/Plus-Icon.svg" alt="Upload File"/>
            </button>

            <div class="upload-menu" style="@_uploadMenuStyle">
                <div class="content tenor" @onmousedown:stopPropagation="true">
                    @* Somewhat creative way to call main upload element *@
                    <button class="button" @onmousedown="@OnClickUploadAsync">
                        Upload a File
                    </button>
                    <button class="button tenor" @onmousedown="@ShowTenorMenu">
                        Gifs via Tenor
                    </button>
                </div>
                <div class="carrot" />
            </div>


            @if (DeviceInfo.IsMobile && CanUserPost){
                <div class="send-wrapper" @onclick="@OnSubmitClick" @onclick:stopPropagation="true" @onclick:preventDefault="true">
                    <img class='send-button' src="_content/Valour.Client/media/send-icon.svg" alt="Send Message" />
                </div>
            }
            
            @if (!CanUserPost)
            {
                <p class="input-placeholder">You lack permission to send messages in this channel</p>
            }
            else if (PreviewMessage is null || PreviewMessage.IsEmpty)
            {
                <p class="input-placeholder">@PlaceholderText</p>
            }

            <div class="textbox-wrapper">
                <div @ref="InnerInputRef" contenteditable='@(CanUserPost ? "true" : "false")' class="textbox-inner" id="text-input-@Window.Id" data-window="@Window.Id" rows="1" @onclick:stopPropagation="true" @onclick:preventDefault="true" onclick="document.getElementById('text-input-@Window.Id').focus()" autofocus>
                </div>
            </div>
        </div>
    </div>
</div>



@code {

    [CascadingParameter]
    public ChatChannelWindowComponent WindowComponent { get; set; }

    [CascadingParameter]
    public ChatChannelWindow Window { get; set; }

    [CascadingParameter]
    public IModalService Modal { get; set; }

    /// <summary>
    /// A reference to the container for message rendering
    /// </summary>
    protected MessageHolderComponent MessageHolder { get; set; }

    /// <summary>
    /// Placeholder text shown in the input box when empty
    /// </summary>
    protected virtual string PlaceholderText { get; }

    /// <summary>
    /// The tenor menu component
    /// </summary>
    private TenorMenuComponent TenorMenu { get; set; }

    /// <summary>
    /// A reference to the inner input component
    /// </summary>
    private ElementReference InnerInputRef { get; set; }

    /// <summary>
    /// The component that displays the mention selection
    /// </summary>
    private MentionSelectComponent MentionSelector { get; set; }

    /// <summary>
    /// True if this input is currently editing a message
    /// </summary>
    public bool IsEditing { get; set; }

    /// <summary>
    /// The message component for the preview message
    /// </summary>
    public MessageComponent PreviewMessageComponent { get; private set; }

    /// <summary>
    /// The preview message
    /// </summary>
    protected ClientMessageWrapper PreviewMessage { get; set; }

    /// <summary>
    /// Dotnet object reference for use in Javascript
    /// </summary>
    private DotNetObjectReference<InputComponent> _thisRef;

    /// <summary>
    /// Module for calling Javascript functions
    /// </summary>
    private IJSInProcessObjectReference _jsModule;

    /// <summary>
    /// If the current user is able to post messages using this input
    /// </summary>
    protected bool CanUserPost { get; set; } = true; // Start as true

    /// <summary>
    /// Allows this component to render when true
    /// </summary>
    public bool CanRenderFlag { get; set; }

    private DateTime _lastTypingUpdateSent = DateTime.MinValue;

    private string _uploadMenuStyle = "display: none;";

    /// <summary>
    /// Run when the component is initialized
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await SetupNewChannelAsync();
    }

    protected override bool ShouldRender()
        => CanRenderFlag;

    public void Refresh()
    {
        CanRenderFlag = true;
        StateHasChanged();
    }

    public async Task ShowTenorMenu()
    {
        await TenorMenu.Show();
    }

    private void ShowUploadMenu()
    {
        if (_uploadMenuStyle != "")
        {
            _uploadMenuStyle = "";
            Refresh();
        }
    }

    private void HideUploadMenu()
    {
        if (_uploadMenuStyle != "display: none;")
        {
            _uploadMenuStyle = "display: none;";
            Refresh();   
        }
    }

    private async Task OnClickUploadAsync()
    {
        await _jsModule.InvokeVoidAsync("OpenUploadFile", Window.Id);
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        windowManager.NotYetSentMessages.Remove(WindowComponent.Channel.Id, out var _);
        _thisRef.Dispose();
        await _jsModule.DisposeAsync();
    }

    public virtual async Task SetupNewChannelAsync()
    {
        WindowComponent.InputComponent = this;
        MessageHolder = WindowComponent.MessageHolder;

        PreviewMessage = new(BuildNewMessage());

        Refresh();
    }

    public virtual Message BuildNewMessage()
    {
        // Other message building
        return null;
    }

    public async Task SetInputContent(string content)
    {
        await _jsModule.InvokeVoidAsync("setInputContent", Window.Id, content);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _thisRef = DotNetObjectReference.Create(this);
            _jsModule = await JsRuntime.InvokeAsync<IJSInProcessObjectReference>("import", "./_content/Valour.Client/Components/Windows/ChannelWindows/InputComponent.razor.js?version=2");
            await SetupJSAsync();
            await JsRuntime.InvokeAsync<IJSObjectReference>("initializeFileDropZone", DropZoneElement, InputFile_Ref.Element);

            await OnAfterJsSetupAsync();
        }

        CanRenderFlag = false;
    }

    public virtual Task OnAfterJsSetupAsync()
    {
        return Task.CompletedTask;
    }

    #region File Drop System

    // Drop zone stuff
    public InputFile InputFile_Ref { get; set; }
    ElementReference DropZoneElement { get; set; }
    IJSObjectReference dropZoneInstance;

    /// <summary>
    /// Image MIME types supported by the input box 
    /// </summary>
    public static HashSet<string> ImageContent = new HashSet<string>()
    {
        "image/gif",
        "image/jpeg",
        "image/png",
        "image/tiff",
        "image/vnd.microsoft.icon",
        "image/x-icon",
        "image/vnd.djvu",
        "image/svg+xml"
    };

    public async Task OnBeginEdit(ClientMessageWrapper message)
    {
        PreviewMessage = message;
        await PreviewMessageComponent.SetMessage(PreviewMessage);

        Refresh();
    }

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        //var file = await e.File.RequestImageFileAsync("jpeg", 256, 256);

        var file = e.File;

        if (file == null)
        {
            Console.WriteLine("Could not load file as an image.");
        }

        if (file.Size > 10240000)
        {
            Console.WriteLine("Max upload size is 10mb.");
        }

        byte[] data = new byte[file.Size];

        await file.OpenReadStream(10240000).ReadAsync(data);

        var content = new MultipartFormDataContent();
        var arrContent = new ByteArrayContent(data);
        if (!string.IsNullOrWhiteSpace(file.ContentType))
        {
            arrContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
        }

        content.Add(arrContent, file.Name, file.Name);

        string type = "File";

        if (ImageContent.Contains(file.ContentType)){
            type = "Image";
        }

        MessageAttachment newAttachment = new()
        {
            MimeType = file.ContentType,
            FileName = file.Name
        };

        ModalParameters modalParams = new();
        modalParams.Add("Data", data);
        modalParams.Add("Attachment", newAttachment);
        modalParams.Add("OnConfirm", 
            async () => {
                var result = await ValourClient.PrimaryNode.PostAsyncWithResponse<string>($"upload/{type}", content);

                if (result.Success)
                {
                    newAttachment.Location = result.Data;
                    await AddMessageAttachment(newAttachment);
                }
                else
                {
                    Console.WriteLine(result.Message);
                }
            }
        );

        Modal.Show<FileUploadComponent>("File Upload", modalParams);

        Refresh();
    }

    public async Task RemoveAttachment(int id)
    {
        var attachments = PreviewMessage.Message.Attachments;
        if (attachments is null)
            return;

        if (id > attachments.Count - 1)
            return;

        attachments.RemoveAt(id);

        PreviewMessage.Message.SetAttachments(attachments);

        await RefreshPreviewMessage();
        Refresh();
    }

    #endregion

    public async Task AddTenor(Media media)
    {
        var format = media.GetFormat(MediaFormatType.gif);

        await AddMessageAttachment(new MessageAttachment()
        {
            Location = format.Url,
            MimeType = "image/gif",
            Width = format.Dims[0],
            Height = format.Dims[1],
            FileName = media.Title + ".gif"
        });
    }

    public async Task UpdateMentionMenu(string text)
    {
        //Console.WriteLine(text);

        if (text.StartsWith('@') || text.StartsWith('#'))
        {
            if (!MentionSelector.Visible)
            {
                MentionSelector.SetVisible(true, text[0]);
            }

            await MentionSelector.SetText(text);
        }
        else
        {
            if (MentionSelector.Visible){
                MentionSelector.SetVisible(false);
            }
        }

        Refresh();
    }

    public async Task AddMessageAttachment(MessageAttachment attachment)
    {
        var attachments = PreviewMessage.Message.Attachments;
        attachments ??= new List<MessageAttachment>();

        attachments.Add(attachment);
        PreviewMessage.Message.SetAttachments(attachments);

        await RefreshPreviewMessage();
        Refresh();
    }

    public async Task RefreshPreviewMessage() {
        PreviewMessage.Clear();
        PreviewMessage.Message.TimeSent = DateTime.UtcNow;
        PreviewMessage.GenerateForPost();
        await PreviewMessageComponent.SetMessage(PreviewMessage);
    }

    public async Task SetReplyMessage(ClientMessageWrapper message)
    {
        PreviewMessageComponent.ReplyMessage = message;
        PreviewMessage.Message.ReplyToId = message?.Message?.Id;

        await RefreshPreviewMessage();
        Refresh();

        await InnerInputRef.FocusAsync();
    }

    public async Task RemoveReply()
    {
        PreviewMessage.Message.ReplyToId = null;
        PreviewMessageComponent.ReplyMessage = null;
        PreviewMessageComponent.ReRender();
    }

    public async Task PostMessage(ClientMessageWrapper messageWrapper)
    {
        messageWrapper.GenerateForPost();
        MessageHolder.AddQueuedMessage(messageWrapper);

        var result = await messageWrapper.Message.PostMessageAsync();

        if (!result.Success)
        {
            MessageHolder.RemoveQueuedMessage(messageWrapper.Message.Fingerprint);

            DirectMessage errorMsg = new()
            {
                Content = $"Hey there, friend! Your message didn't post properly.\n Reason: {result.Message}",
                AuthorUserId = long.MaxValue,
                ChannelId = Window.Channel.Id,
                Id = 0
            };

            MessageHolder.RemoveErrorMessage();
            await MessageHolder.AddMessage(new ClientMessageWrapper(errorMsg));
        }
        else
        {
            MessageHolder.RemoveErrorMessage();
        }

        PreviewMessageComponent.ReplyMessage = null;
        PreviewMessage.Clear();
        PreviewMessageComponent.ReRender();
        windowManager.NotYetSentMessages.Remove(WindowComponent.Channel.Id, out var _);
    }

    /////////////////////
    // JS Interop Zone //
    /////////////////////

    // C# -> JS
    private async Task SetupJSAsync()
    {
        await _jsModule.InvokeVoidAsync("setup", Window.Id, _thisRef);
    }

    public async Task InjectElementAsync(string text, string coverText, string classList, string styleList)
    {
        await _jsModule.InvokeVoidAsync("injectElement", text, coverText, classList, styleList, Window.Id);
    }

    public async Task OnSubmitClick()
    {
        await _jsModule.InvokeVoidAsync("submitMessage", Window.Id, true);
    }

    // JS -> C#
    [JSInvokable]
    public async Task OnCaretUpdate(string currentWord)
    {
        await UpdateMentionMenu(currentWord);
    }

    /// <summary>
    /// This runs every time a key is pressed when the chatbox is selected
    /// </summary>
    [JSInvokable]
    public async Task OnChatboxUpdate(string input, string currentWord)
    {
        //Console.WriteLine(input);

        await UpdateMentionMenu(currentWord);

        if (input is not null)
        {
            // Fix for dumb formatting in HTML
            input = input.Replace("\n\n«", "«").Replace("» \n\n", "»");
        }

        windowManager.NotYetSentMessages[WindowComponent.Channel.Id] = input;
        PreviewMessage.Message.Content = input;
        await RefreshPreviewMessage();

        await MessageHolder.ScrollToBottom();

        if (DateTime.UtcNow > _lastTypingUpdateSent.AddSeconds(5))
        {
            WindowComponent.Channel.SendIsTyping();
            _lastTypingUpdateSent = DateTime.UtcNow;
        }

        Refresh();
    }

    [JSInvokable]
    public async Task MentionSubmit()
    {
        await MentionSelector.Submit();

        Refresh();
    }

    [JSInvokable]
    public void MoveMentionSelect(int n)
    {
        MentionSelector.MoveSelect(n);
    }

    [JSInvokable]
    public async Task OnChatboxSubmit()
    {
        if (PreviewMessage.Message.Content is not null)
        {
            PreviewMessage.Message.Content =
                PreviewMessage.Message.Content.TrimEnd('\n');

            PreviewMessage.Message.Content =
                PreviewMessage.Message.Content.Trim();
        }

        if (PreviewMessage.IsEmpty)
        {
            return;
        }

        var postMessage = new ClientMessageWrapper(PreviewMessage.Message);

        // New message for preview
        PreviewMessage = new(BuildNewMessage());
        await PreviewMessageComponent.SetMessage(PreviewMessage);

        await OnChatboxUpdate(null, "");

        // Post message to server
        //StateHasChanged();
        await PostMessage(postMessage);
    }
}
