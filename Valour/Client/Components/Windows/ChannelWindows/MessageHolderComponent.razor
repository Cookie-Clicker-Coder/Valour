@inject IJSRuntime JsRuntime
@implements IAsyncDisposable
@using Valour.Api.Models.Messages
@using System.Reflection.Metadata
<ContextMenuTrigger @key="@_id" Id="@_id" CssClass="chat-holder mt-auto"  MouseButtonTrigger="MouseButtonTrigger.ContextOrHold" @onpointerdown:stopPropagation="true" MenuId="message-context">
    <CascadingValue Value="this" IsFixed="true">
        @{
            ClientMessageWrapper last;    

            if (DisplayedMessageData != null && DisplayedMessageData.Count > 0)
            {
                last = null;
                
                foreach (ClientMessageWrapper messageData in DisplayedMessageData)
                {
                    Dictionary<string, object> messageParams = new()
                    {
                        { "MessageData", messageData },
                        { "IsInnerReply", false },
                        { "LastMessage", last },
                    };

                    <DynamicComponent Type="@messageData.GetComponentType()" Parameters="messageParams" @key='messageData'></DynamicComponent>

                    last = messageData;
                }
            }

            if (QueuedMessageData != null && QueuedMessageData.Count > 0){

                last = null;

                if (DisplayedMessageData != null)
                {
                    last = DisplayedMessageData.Last();
                }

                foreach (ClientMessageWrapper messageData in QueuedMessageData)
                {
                    Dictionary<string, object> messageParams = new()
                    {
                        { "MessageData", messageData },
                        { "IsInnerReply", false },
                        { "LastMessage", last },
                        { "Ghost", true }
                    };

                    <DynamicComponent Type="@messageData.GetComponentType()" Parameters="messageParams" @key='messageData'></DynamicComponent>

                    last = messageData;
                }
            }
        }
    </CascadingValue>
    
    <div id="anchor" style="overflow-anchor: auto; height: 1px;"></div>
</ContextMenuTrigger>

@code {
    [CascadingParameter]
    public ChatChannelWindow Window { get; set; }

    [Parameter]
    public List<ClientMessageWrapper> DisplayedMessageData { get; set; }

    public List<ClientMessageWrapper> QueuedMessageData { get; set; }

    public List<MessageComponent> RenderedMessages { get; set; }

    private DotNetObjectReference<MessageHolderComponent> _thisRef;

    private IJSInProcessObjectReference _jsModule;

    public string state = "none";

    private string _id;

    protected override void OnInitialized()
    {
        _id = "innerwindow-" + Window.Id;
        
        RenderedMessages = new List<MessageComponent>();
        DisplayedMessageData = new List<ClientMessageWrapper>();
        QueuedMessageData = new List<ClientMessageWrapper>();

        ValourClient.OnMessageDeleted += OnDeleteMessage;

        _thisRef = DotNetObjectReference.Create<MessageHolderComponent>(this);

        StateHasChanged();
    }

    public void AddQueuedMessage(ClientMessageWrapper message)
    {
        QueuedMessageData.Add(message);
        StateHasChanged();
    }

    public void RemoveQueuedMessage(string fingerprint)
    {
        var queued = QueuedMessageData.FirstOrDefault(x => x.Message.Fingerprint == fingerprint);
        if (queued != null) { QueuedMessageData.Remove(queued); }

        StateHasChanged();
    }

    public void RemoveErrorMessage()
    {
        var error = DisplayedMessageData.FirstOrDefault(x => x.Message.Id == 0);
        if (error != null) { 
            QueuedMessageData.Remove(error); 
            StateHasChanged();
        }
    }

    public void Clear()
    {
        DisplayedMessageData.Clear();
        QueuedMessageData.Clear();
        RenderedMessages.Clear();
        StateHasChanged();
    }

    public ClientMessageWrapper GetLastMessage()
    {
        if (QueuedMessageData != null && QueuedMessageData.Count > 0){
            return QueuedMessageData.Last();
        }
        else if (DisplayedMessageData != null && DisplayedMessageData.Count > 0)
        {
            return DisplayedMessageData.Last();
        }

        return null;
    }

    public void AddMessages(List<ClientMessageWrapper> messages, bool refresh = true)
    {
        DisplayedMessageData.AddRange(messages);

        if (refresh)
        {
            StateHasChanged();
        }
    }

    public void InsertMessages(int position, List<ClientMessageWrapper> messages, bool refresh = true)
    {
        //foreach(var m in messages)
        //{
        //    Console.WriteLine(m.Content);
        //}

        DisplayedMessageData.InsertRange(position, messages);

        if (refresh)
        {
            StateHasChanged();
        }
    }

    public async Task AddMessage(ClientMessageWrapper renderData, bool refresh = true)
    {
        QueuedMessageData.RemoveAll(x => x.Message.Fingerprint == renderData.Message.Fingerprint);

        //Get current window scroll pos
        bool IsAtBottom = await _jsModule.InvokeAsync<bool>("isAtBottom", Window.Id);

        // check if theres too many messages
        if (IsAtBottom && DisplayedMessageData.Count > 120)
        {
            DisplayedMessageData.RemoveRange(0, DisplayedMessageData.Count - 120);
        }

        DisplayedMessageData.Add(renderData);

        // Flag for UI refresh
        if (refresh)
        {
            StateHasChanged();
        }

        await ScrollToBottom();
    }

    public void ForceRefresh()
    {
        state = "force-ref";
        StateHasChanged();
    }

    public void AddRenderedMessage(MessageComponent message)
    {
        RenderedMessages.Add(message);
    }

    public void RemoveRenderedMessage(MessageComponent message)
    {
        RenderedMessages.Remove(message);
    }

    //protected override async Task OnParametersSetAsync()
    //{

    //}

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        ValourClient.OnMessageDeleted -= OnDeleteMessage;
        await _jsModule.DisposeAsync();
    }

    public async Task OnDeleteMessage(PlanetMessage message)
    {
        if (message.ChannelId != Window.Channel.Id)
            return;

        DisplayedMessageData.RemoveAll(x => x.Message.Id == message.Id);
        QueuedMessageData.RemoveAll(x => x.Message.Id == message.Id);

        var nextMessage = RenderedMessages.FirstOrDefault(x => x.MessageData.Message.Id > message.Id);
        if (nextMessage != null){
            var lastMessage = RenderedMessages
                .OrderByDescending(x => x.MessageData.Message.Id)
                .FirstOrDefault(x => x.MessageData.Message.Id < message.Id);
            nextMessage.SetLast(lastMessage.MessageData);
            await nextMessage.RefreshMessage();
            nextMessage.ReRender();
        }

        ForceRefresh();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JsRuntime.InvokeAsync<IJSInProcessObjectReference>("import", "./_content/Valour.Client/Components/Windows/ChannelWindows/MessageHolderComponent.razor.js");
            await SetupJS();
            await ScrollToBottom();
        }

        state = GetState();
    }

    public string GetState()
    {
        if (DisplayedMessageData == null || DisplayedMessageData.Count == 0)
        {
            return "none";
        }
        else
        {
            return $"{DisplayedMessageData.First().Message.Id}-{DisplayedMessageData.Last().Message.Id}-{QueuedMessageData.Count}";
        }
    }

    protected override bool ShouldRender()
    {
        return GetState() != state;
    }

    /////////////////////
    // JS Interop Zone //
    /////////////////////

    public async Task SetupJS()
    {
        await _jsModule.InvokeVoidAsync("setup", Window.Id, _thisRef);
    }

    public async Task ScrollToBottom(bool force = false)
    {
        if (_jsModule is not null)
            await _jsModule.InvokeVoidAsync("scrollToBottom", Window.Id, force);
    }

    public async Task ScrollToBottomAnimated()
    {
        await _jsModule.InvokeVoidAsync("scrollToBottomAnimated", Window.Id);
    }

    public async Task UpdateScrollPosition()
    {
        await _jsModule.InvokeVoidAsync("updateScrollPosition", Window.Id);
    }

    public async Task ScaleScrollPosition()
    {
        await _jsModule.InvokeVoidAsync("scaleScrollPosition", Window.Id);
    }

    [JSInvokable("OnScrollTopInvoke")]
    public async Task OnScrollTop()
    {
        if (DisplayedMessageData == null ||
            DisplayedMessageData.Count == 0)
        {
            return;
        }

        long firstId = DisplayedMessageData[0].Message.Id;

        Console.WriteLine($"Fetching older messages from id {firstId} for window {Window.Id}");

        var messages = await Window.Channel.GetMessagesGenericAsync(firstId, 64);

        if (messages == null || messages.Count() == 0)
            return;

        foreach (var msg in messages)
        {
            await msg.AddToCache(msg);
            var reply = msg.GetReply();
            if (reply is not null)
            {
                await reply.AddToCache(reply);
            }
        }

        await UpdateScrollPosition(); // This saves the scroll position

        InsertMessages(0, ClientMessageWrapper.FromList(messages));

        await ScaleScrollPosition(); // This ensures the page doesnt move harshly
    }
}