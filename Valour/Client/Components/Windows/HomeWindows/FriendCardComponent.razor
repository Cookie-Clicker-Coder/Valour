@inject WindowManager windowManager
@inject IJSRuntime JS
@implements IDisposable

<div id="flipper-friend-@Friend.Id-@Window.Id" class="flipper" onmouseover="determineFlip('flipper-friend-@Friend.Id-@Window.Id', 220)" @onclick="OnClick"> 
    <ContextMenuTrigger style="display: inline-block;" MouseButtonTrigger="MouseButtonTrigger.ContextOrHold" MenuId='user-context' @onpointerdown='async () => await UserContextMenuComponent.Initialize(Friend)'>
        <div class="outer-circle">
            <div class="text-hide-circle" />
            <img src='@iconUrl' class="icon" @onerror='OnIconError' style='@image_style'/>
            @if (IsUnread)
            {
                <div class="noti">
                </div>
            }
            <div class="rect-slide">
                <div class="text-wrapper">
                    <div class="text-flex">
                        <b class="friend-name">@Friend.Name</b>
                    </div>
                </div>
            </div>
        </div>
    </ContextMenuTrigger>
</div>

@code {
    [Parameter]
    public User Friend { get; set; }

    [Parameter]
    public HomeWindow Window { get; set; }

    [Parameter]
    public HomeWindowComponent homeWindowComponent { get; set; }

    public string iconUrl = "_content/Valour.Client/media/logo/logo-256.png";

    public string image_style = "";
    public bool IsUnread = false;

    protected override async Task OnInitializedAsync(){
        if (!string.IsNullOrWhiteSpace(Friend.PfpUrl))
        {
            iconUrl = Friend.PfpUrl;
        }

        homeWindowComponent.RerenderFriendCards += Refresh;
    }

    public async Task Refresh()
    {
        // in the future, we might want a route that grabs all the direct chat channels' states
        IsUnread = DetermineUnread(await DirectChatChannel.FindAsyncByUser(Friend.Id, true));
        StateHasChanged();
    }

    public void Dispose()
    {
        homeWindowComponent.RerenderFriendCards -= Refresh;
    }

    public bool DetermineUnread(DirectChatChannel chatChannel)
    {
        if (ValourClient.OpenPlanetChannels.Any(x => x.Id == chatChannel.Id))
            return false;

        if (!ValourClient.ChannelStateTimes.ContainsKey(chatChannel.Id))
            return true;

        ValourClient.ChannelStateTimes.TryGetValue(chatChannel.Id, out var lastRead);
        if (lastRead is null)
            lastRead = DateTime.MaxValue;

        return lastRead < chatChannel.TimeLastActive;
    }

    public async Task OnClick()
    {
        // Get dm channel
        var channel = await DirectChatChannel.FindAsyncByUser(Friend.Id);
        var newWindow = new DirectChatChannelWindow(channel);

        Console.WriteLine($"Switching window {Window.Id} to direct chat channel {channel.Id}");

        await windowManager.ReplaceWindow(Window, newWindow);
        await windowManager.SetSelectedWindow(newWindow);
        await windowManager.SetFocusedPlanet(null);

        StateHasChanged();
    }

    protected void OnIconError()
    {
        iconUrl = "_content/Valour.Client/media/logo/logo-256.png";

        int r = Random.Shared.Next(24) * 15;

        image_style = $"filter: hue-rotate({r}deg)";

        StateHasChanged();
    }
}